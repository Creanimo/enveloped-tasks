"use strict";
/* eslint-disable sort-imports */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chokidar_1 = __importDefault(require("chokidar"));
const misc_1 = require("./misc");
const fs_1 = __importDefault(require("fs"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const morgan_1 = __importDefault(require("morgan"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
// FIX: Packages are not maintained anymore (replace them!)
const express_1 = __importDefault(require("express")); // const connect = require('connect')
const serve_index_1 = __importDefault(require("./dependencies/serve-index")); // const serveIndex = require('serve-index')
// MOD: Replaced "faye-websocket" by "ws"
// const WebSocket: any = require('faye-websocket')
const ws_1 = __importDefault(require("ws")); // eslint-disable-line sort-imports
// MOD: Replaced "opn" by "open"
// const open = require('opn')
const open_1 = __importDefault(require("open"));
const colors_1 = require("./colors");
const staticServer_1 = require("./staticServer");
const getCertificate_1 = require("./utils/getCertificate");
// const INJECTED_CODE = fs.readFileSync(path.join(__dirname, '../injected.html'), 'utf8')
const INJECTED_CODE = fs_1.default.readFileSync(path_1.default.join(__dirname, '../injected.js'), 'utf8');
class LiveServer {
    constructor() {
        this.logLevel = 2;
        this.injectBody = false;
        this.colors = ['blue', 'magenta', 'cyan', 'green', 'red', 'yellow'];
        this.colorIndex = -1;
        this.newColor = () => {
            this.colorIndex++;
            return this.colors[this.colorIndex % this.colors.length];
        };
        // WebSocket clients
        this.clients = [];
        // http sockets
        this.sockets = new Set();
    }
    get openURL() {
        return this._openURL;
    }
    get protocol() {
        return this._protocol;
    }
    get isRunning() {
        var _a;
        return !!((_a = this.httpServer) === null || _a === void 0 ? void 0 : _a.listening);
    }
    /** Start five-server */
    start(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options._cli) {
                const opts = misc_1.getConfigFile(options.configFile, options.workspace);
                options = Object.assign(Object.assign({}, opts), options);
            }
            const { browser = null, cors = false, file, host = 'localhost', // '0.0.0.0'
            htpasswd = null, https: _https = null, injectBody = false, injectCss = true, logLevel = 2, middleware = [], mount = [], port = 8080, proxy = [], remoteLogs = false, wait = 100, workspace } = options;
            this.injectBody = injectBody;
            let watch = options.watch;
            if (watch === true)
                watch = undefined;
            if (watch === false)
                watch = false;
            else if (watch && !Array.isArray(watch))
                watch = [watch];
            const root = options.root || process.cwd();
            const rootPath = workspace ? path_1.default.join(workspace, options.root ? options.root : '') : root;
            const watchPaths = watch || [rootPath];
            let openPath = options.open;
            if (typeof openPath === 'string')
                openPath = misc_1.removeLeadingSlash(openPath);
            else if (Array.isArray(openPath))
                openPath.map(o => misc_1.removeLeadingSlash(o));
            else if (openPath === undefined || openPath === true)
                openPath = '';
            else if (openPath === null || openPath === false)
                openPath = null;
            if (options.noBrowser)
                openPath = null; // Backwards compatibility with 0.7.0
            // if server is already running, just open a new browser window
            if (this.isRunning) {
                console.log(colors_1.colors(`Opening new window at ${this.openURL}`, 'green'));
                this.launchBrowser(openPath, browser);
                return;
            }
            this.logLevel = logLevel;
            const staticServerHandler = staticServer_1.staticServer(rootPath, { logLevel, injectedCode: INJECTED_CODE });
            const httpsModule = 'https';
            // let httpsModule = options.httpsModule
            // if (httpsModule) {
            //   try {
            //     require.resolve(httpsModule)
            //   } catch (e) {
            //     console.error(colors(`HTTPS module "${httpsModule}" you've provided was not found.`, 'red'))
            //     console.error('Did you do', `"npm install ${httpsModule}"?`)
            //     // @ts-ignore
            //     return
            //   }
            // } else {
            //   httpsModule = 'https'
            // }
            // Setup a web server
            const app = express_1.default();
            app.use((req, res, next) => {
                if (req.url === '/fiveserver.js') {
                    return res.type('.js').send(INJECTED_CODE);
                }
                if (req.url === '/fiveserver') {
                    return res.json({ status: 'online' });
                }
                next();
            });
            // Add logger. Level 2 logs only errors
            if (this.logLevel === 2) {
                app.use(morgan_1.default('dev', {
                    skip: function (req, res) {
                        return res.statusCode < 400;
                    }
                }));
                // Level 2 or above logs all requests
            }
            else if (this.logLevel > 2) {
                app.use(morgan_1.default('dev'));
            }
            if (options.spa) {
                // @ts-expect-error
                middleware.push('spa');
            }
            // Add middleware
            middleware.map(function (mw) {
                if (typeof mw === 'string') {
                    const ext = path_1.default.extname(mw).toLocaleLowerCase();
                    // TODO: Try to use a better import syntax
                    // require().default does just not look right :/
                    if (ext !== '.js') {
                        mw = require(path_1.default.join(__dirname, 'middleware', `${mw}.js`)).default;
                    }
                    else {
                        mw = require(mw);
                    }
                    if (typeof mw !== 'function')
                        misc_1.error(`middleware ${mw} does not return a function`);
                }
                app.use(mw);
            });
            // Use http-auth if configured
            if (htpasswd !== null) {
                // TODO: Replace http-auth with a lib that does not have native code
                misc_1.error('Sorry htpasswd does not work yet.');
                // const auth = require('http-auth')
                // const authConnect = require('http-auth-connect')
                // const basic = auth.basic({
                //   realm: 'Please authorize',
                //   file: htpasswd
                // })
                // app.use(authConnect(basic))
            }
            if (cors) {
                app.use(require('cors')({
                    origin: true,
                    credentials: true // allowing requests with credentials
                }));
            }
            mount.forEach(mountRule => {
                const mountPath = path_1.default.resolve(process.cwd(), mountRule[1]);
                if (!options.watch)
                    // Auto add mount paths to watching but only if exclusive path option is not given
                    watchPaths.push(mountPath);
                // make sure mountRule[0] has a leading slash
                if (mountRule[0].indexOf('/') !== 0)
                    mountRule[0] = `/${mountRule[0]}`;
                // mount it with  express.static
                app.use(mountRule[0], express_1.default.static(mountPath));
                // log the mapping folder
                if (this.logLevel >= 1)
                    console.log('Mapping %s to "%s"', mountRule[0], mountPath);
            });
            proxy.forEach(proxyRule => {
                const url = new URL(proxyRule[1]);
                const proxyOpts = {
                    hash: url.hash,
                    host: url.host,
                    hostname: url.hostname,
                    href: url.href,
                    origin: url.origin,
                    password: url.password,
                    path: url.pathname + url.search,
                    pathname: url.pathname,
                    port: url.port,
                    preserveHost: true,
                    protocol: url.protocol,
                    search: url.search,
                    searchParams: url.searchParams,
                    username: url.username,
                    via: true
                };
                app.use(proxyRule[0], require('./dependencies/proxy-middleware')(proxyOpts));
                if (this.logLevel >= 1)
                    console.log('Mapping %s to "%s"', proxyRule[0], proxyRule[1]);
            });
            app
                .use(staticServerHandler) // Custom static server
                .use(staticServer_1.entryPoint(staticServerHandler, file))
                .use(serve_index_1.default(rootPath, { icons: true }));
            if (_https !== null && _https !== false) {
                let httpsConfig = _https;
                if (typeof _https === 'string') {
                    httpsConfig = require(path_1.default.resolve(process.cwd(), _https));
                }
                if (_https === true) {
                    const fakeCert = getCertificate_1.getCertificate(path_1.default.join(workspace ? workspace : path_1.default.resolve(), '.cache'));
                    httpsConfig = { key: fakeCert, cert: fakeCert };
                }
                this.httpServer = https_1.default.createServer(httpsConfig, app);
                this._protocol = 'https';
            }
            else {
                this.httpServer = http_1.default.createServer(app);
                this._protocol = 'http';
            }
            // Setup server to listen at port
            yield this.listen(port, host);
            const address = this.httpServer.address();
            const serveHost = address.address === '0.0.0.0' ? '127.0.0.1' : address.address;
            const openHost = host === '0.0.0.0' ? '127.0.0.1' : host;
            const serveURL = `${this._protocol}://${serveHost}:${address.port}`;
            this._openURL = `${this._protocol}://${openHost}:${address.port}`;
            let serveURLs = [serveURL];
            if (this.logLevel > 2 && address.address === '0.0.0.0') {
                const ifaces = os_1.default.networkInterfaces();
                serveURLs = Object.keys(ifaces).map(iface => {
                    return ifaces[iface];
                });
                serveURLs = serveURLs
                    // flatten address data, use only IPv4
                    .reduce(function (data, addresses) {
                    addresses
                        .filter(function (addr) {
                        return addr.family === 'IPv4';
                    })
                        .forEach(function (addr) {
                        data.push(addr);
                    });
                    return data;
                }, [])
                    .map(addr => {
                    return `${this._protocol}://${addr.address}:${address.port}`;
                });
            }
            // Output
            if (this.logLevel >= 1) {
                if (serveURL === this.openURL)
                    if (serveURLs.length === 1) {
                        console.log(colors_1.colors('Serving "%s" at %s', 'green'), root, serveURLs[0]);
                    }
                    else {
                        console.log(colors_1.colors('Serving "%s" at\n\t%s', 'green'), root, serveURLs.join('\n\t'));
                    }
                else
                    console.log(colors_1.colors('Serving "%s" at %s (%s)', 'green'), root, this.openURL, serveURL);
            }
            this.launchBrowser(openPath, browser);
            const wss = new ws_1.default.Server({ server: this.httpServer });
            wss.on('connection', (ws, req) => {
                var _a;
                if (remoteLogs !== false)
                    ws.send('initRemoteLogs');
                ws.send('connected');
                ws.sendWithDelay = (data, cb) => {
                    setTimeout(() => {
                        ws.send(data, e => {
                            if (cb)
                                cb(e);
                        });
                    }, wait, { once: true });
                };
                ws.ip = (_a = req === null || req === void 0 ? void 0 : req.connection) === null || _a === void 0 ? void 0 : _a.remoteAddress;
                ws.color = typeof remoteLogs === 'string' ? remoteLogs : this.newColor();
                // ws.on('error', err => {
                //   console.log('WS ERROR:', err)
                // })
                ws.on('message', data => {
                    try {
                        if (typeof data === 'string') {
                            const json = JSON.parse(data);
                            if (json && json.file) {
                                ws.file = json.file;
                            }
                            const useRemoteLogs = remoteLogs === true || typeof remoteLogs === 'string';
                            if (useRemoteLogs && json && json.console) {
                                const ip = `[${ws.ip}]`;
                                const msg = json.console.message;
                                const T = json.console.type;
                                const t = T === 'warn' ? ' (warn) ' : T === 'error' ? ' (error) ' : ' ';
                                console[T](colors_1.colors(`${ip}${t}${msg}`, ws.color));
                            }
                        }
                    }
                    catch (err) {
                        //
                    }
                });
                ws.on('close', () => {
                    this.clients = this.clients.filter(function (x) {
                        return x !== ws;
                    });
                });
                this.clients.push(ws);
            });
            let ignored = [
                function (testPath) {
                    // Always ignore dotfiles (important e.g. because editor hidden temp files)
                    return testPath !== '.' && /(^[.#]|(?:__|~)$)/.test(path_1.default.basename(testPath));
                }
            ];
            if (options.ignore) {
                ignored = ignored.concat(options.ignore);
            }
            if (options.ignorePattern) {
                ignored.push(options.ignorePattern);
            }
            // Setup file watcher
            if (watch === false)
                return;
            this.watcher = chokidar_1.default.watch(watchPaths, {
                ignored: ignored,
                ignoreInitial: true
            });
            const handleChange = changePath => {
                const htmlChange = path_1.default.extname(changePath) === '.html';
                if (htmlChange && injectBody)
                    return;
                const cssChange = path_1.default.extname(changePath) === '.css' && injectCss;
                if (this.logLevel >= 1) {
                    if (cssChange)
                        console.log(colors_1.colors('CSS change detected', 'magenta'), changePath);
                    else
                        console.log(colors_1.colors('Change detected', 'cyan'), changePath);
                }
                this.clients.forEach(ws => {
                    if (ws)
                        ws.sendWithDelay(cssChange ? 'refreshcss' : 'reload');
                });
            };
            this.watcher
                .on('change', handleChange)
                .on('add', handleChange)
                .on('unlink', handleChange)
                .on('addDir', handleChange)
                .on('unlinkDir', handleChange)
                .on('ready', () => {
                if (this.logLevel >= 1)
                    console.log(colors_1.colors('Ready for changes', 'cyan'));
            })
                .on('error', err => {
                console.log(colors_1.colors('ERROR:', 'red'), err);
            });
        });
    }
    listen(port, host) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                // Handle server startup errors
                this.httpServer.once('error', e => {
                    // @ts-ignore
                    if (e.message === 'EADDRINUSE' || (e.code && e.code === 'EADDRINUSE')) {
                        const serveURL = `${this._protocol}://${host}:${port}`;
                        console.log(colors_1.colors('%s is already in use. Trying another port.', 'yellow'), serveURL);
                        setTimeout(() => {
                            this.listen(0, host); // 0 means random port
                        }, 1000);
                    }
                    else {
                        console.error(colors_1.colors(e.toString(), 'red'));
                        this.shutdown();
                        reject(e.message);
                    }
                });
                this.httpServer.on('connection', socket => {
                    this.sockets.add(socket);
                });
                // Handle successful httpServer
                this.httpServer.once('listening', ( /*e*/) => {
                    resolve();
                });
                this.httpServer.listen(port, host);
            });
        });
    }
    /**
     * Navigate the browser to another page.
     * @param url Navigates to the given URL.
     */
    navigate(url) {
        this.clients.forEach(ws => {
            if (ws)
                ws.sendWithDelay(JSON.stringify({ navigate: url }));
        });
    }
    /** Launch a new browser window. */
    launchBrowser(path, browser = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const launch = (target, browser = null, index = -1) => __awaiter(this, void 0, void 0, function* () {
                if (!browser)
                    return yield open_1.default(target);
                let res;
                const opn = (browser) => __awaiter(this, void 0, void 0, function* () {
                    const hasArguments = browser.includes('--');
                    if (!hasArguments) {
                        res = yield open_1.default(target, { app: { name: browser } });
                    }
                    if (hasArguments) {
                        const b = browser.split('--').map(c => c.trim());
                        res = yield open_1.default(target, {
                            app: { name: b.shift(), arguments: b.map(arg => `--${arg}`) }
                        });
                    }
                });
                if (typeof browser === 'string')
                    yield opn(browser);
                if (Array.isArray(browser)) {
                    index++;
                    yield opn(browser[index]);
                }
                const launchDefaultBrowser = () => {
                    launch(target);
                };
                res.once('exit', code => {
                    if (code && code > 0) {
                        if (typeof browser === 'string') {
                            console.log(colors_1.colors(`Could not open browser "${browser}". Trying the default browser next.`, 'yellow'));
                            launchDefaultBrowser();
                        }
                        else if (Array.isArray(browser)) {
                            if (typeof browser[index + 1] === 'undefined') {
                                console.log(colors_1.colors(`Could not open browser "${browser[index]}". Trying the default browser next.`, 'yellow'));
                                launchDefaultBrowser();
                            }
                            else {
                                console.log(colors_1.colors(`Could not open browser "${browser[index]}". Trying "${browser[index + 1]}" next.`, 'yellow'));
                                launch(target, browser, index);
                            }
                        }
                    }
                });
            });
            // Don't open a browser
            if (path === null)
                return;
            // Try to open one browser from a list of browsers
            if (Array.isArray(path)) {
                for (const p of path) {
                    yield launch(`${this.openURL}/${p}`, browser);
                }
            }
            // Open browser "browser"
            if (typeof path === 'string') {
                yield launch(`${this.openURL}/${path}`, browser);
            }
        });
    }
    /** Reloads all browser windows */
    reloadBrowserWindow() {
        this.clients.forEach(ws => {
            if (ws)
                ws.sendWithDelay('reload');
        });
    }
    /** Manually refresh css */
    refreshCSS() {
        this.clients.forEach(ws => {
            if (ws)
                ws.sendWithDelay('refreshcss');
        });
    }
    /** Inject new HTML into the body (VSCode only) */
    updateBody(file, body, position) {
        this.clients.forEach(ws => {
            if (ws && ws.file === file)
                ws.sendWithDelay(JSON.stringify({ body, position }));
        });
    }
    highlight(file, position) {
        this.clients.forEach(ws => {
            if (ws && ws.file === file)
                ws.sendWithDelay(JSON.stringify({ position }));
        });
    }
    /** Close five-server (same as shutdown()) */
    get close() {
        return this.shutdown;
    }
    /** Shutdown five-server */
    shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.watcher) {
                yield this.watcher.close();
            }
            for (const client of this.clients) {
                yield client.close();
            }
            for (const socket of this.sockets) {
                socket.destroy();
                this.sockets.delete(socket);
            }
            return new Promise((resolve, reject) => {
                if (this.httpServer && this.httpServer.listening) {
                    this.httpServer.close(err => {
                        if (err)
                            return reject(err.message);
                        else {
                            resolve();
                            // @ts-ignore
                            this.httpServer = null;
                        }
                    });
                }
                else {
                    return resolve();
                }
            });
        });
    }
}
exports.default = LiveServer;
